package gov.va.vinci.chartreview.model.schema;

// Generated Mar 8, 2011 3:41:01 PM by Hibernate Tools 3.2.4.GA

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.validator.GenericValidator;

import javax.persistence.*;
import java.sql.Timestamp;
import java.util.*;

/**
 * ClassDef generated by hbm2java
 */
@Entity
public class ClassDef implements java.io.Serializable, Comparable<ClassDef>
{
    private String name = "New_Classification";
    private String id;
	private String color = "05ff05"; // Green
    private List<AttributeDef> attributeDefs = new ArrayList<AttributeDef>(0);
    private AnnotationSchema annotationSchema;
    private List<ClassDef> classDefs = new ArrayList<ClassDef>(0);
    private List<ClassDefAttributeDefSortOrder> attributeDefSortOrders = new ArrayList<ClassDefAttributeDefSortOrder>(0);
    private List<ClassDefClassDefSortOrder> classDefSortOrders = new ArrayList<ClassDefClassDefSortOrder>(0);
    private Timestamp version = new Timestamp((new Date()).getTime());
    private ClassDef parent = null;

    public ClassDef() {
    }

    public ClassDef(ClassDef obj, Map<AttributeDef, AttributeDef> attributeDefMap, Map<ClassDef, ClassDef> classDefMap) {
        this(obj, attributeDefMap, classDefMap, false);
    }

    public ClassDef(ClassDef obj, Map<AttributeDef, AttributeDef> attributeDefMap, Map<ClassDef, ClassDef> classDefMap, boolean augmentName) {
        this(
                UUID.randomUUID().toString(),
                augmentName ? obj.name + "_copy" : obj.name
        );
        this.color = obj.color;
        for(Iterator iter = obj.attributeDefs.iterator(); iter.hasNext();)
        {
            AttributeDef attributeDef = (AttributeDef)iter.next();
            AttributeDef newAttributeDef = attributeDefMap.get(attributeDef);
            this.addAttributeDef(newAttributeDef);
            for (Iterator iter2 = obj.attributeDefSortOrders.iterator(); iter2.hasNext(); ) {
                ClassDefAttributeDefSortOrder sortOrder = (ClassDefAttributeDefSortOrder) iter2.next();
                if(attributeDef.getId().compareTo(sortOrder.getObjId()) == 0) {
                    ClassDefAttributeDefSortOrder newSortOrder = new ClassDefAttributeDefSortOrder(sortOrder);
                    newSortOrder.setObjId(newAttributeDef.getId());
                    this.addAttributeDefSortOrder(newSortOrder);
                }
            }
        }
        if(classDefMap != null)
        {
            for(Iterator iter = obj.classDefs.iterator(); iter.hasNext();)
            {
                ClassDef classDef = (ClassDef)iter.next();
                // NOTE: During whole schema copy, we will find the ORIGINAL
                // class def, not the copied one, because not all sub-classes
                // will have been copied when we perform the copy of any one
                // class def, so these references will be fixed-up after all
                // sub-classes have been copied in that case.  For the copy
                // of a single class def from the UI, these will be the correct
                // references, except for a self-reference, which will also
                // be fixed up after the copy.
                ClassDef newClassDef = classDefMap.get(classDef);

                // Check to see if this class is a sub-class to itself.  If so, then the object reference
                // needs to be set to THIS, because it will not appear in the given map, since it just now
                // being created...
                if(classDef == obj)
                {
                    newClassDef = this;
                }
                this.addClassDef(newClassDef);

                for (Iterator iter2 = obj.classDefSortOrders.iterator(); iter2.hasNext(); ) {
                    ClassDefClassDefSortOrder sortOrder = (ClassDefClassDefSortOrder) iter2.next();
                    if(classDef.getId().compareTo(sortOrder.getObjId()) == 0) {
                        ClassDefClassDefSortOrder newSortOrder = new ClassDefClassDefSortOrder(sortOrder);
                        newSortOrder.setObjId(newClassDef.getId());
                        this.addClassDefSortOrder(newSortOrder);
                    }
                }
            }
        }
    }

    // Have to call this AFTER schema copy constructor, because the sub-classes may not yet be copied
    // during the schema copy constructor.  Do not need to call this on other copy constructors, only schema.
    public void fixUpSubClasses(Map<ClassDef, ClassDef> classDefMap)
    {
        List<ClassDef> classDefsToRemove = new ArrayList<ClassDef>();
        List<ClassDef> classDefsToFix = new ArrayList<ClassDef>(this.classDefs); // Use this to avoid concurrent modification exception on iteration on a list that may include this class (sub-classed self case)
        for(Iterator iter = classDefsToFix.iterator(); iter.hasNext();)
        {
            ClassDef originalClassDef = (ClassDef)iter.next();
            for(Iterator iter2 = classDefMap.keySet().iterator(); iter2.hasNext();)
            {
                ClassDef tOriginalClassDef = (ClassDef)iter2.next();
                ClassDef newClassDef = classDefMap.get(tOriginalClassDef);
                if(tOriginalClassDef.getId() == originalClassDef.getId())
                {
                    classDefsToRemove.add(originalClassDef);
                    this.addClassDef(newClassDef);
                    for (Iterator iter3 = this.classDefSortOrders.iterator(); iter3.hasNext(); ) {
                        ClassDefClassDefSortOrder newSortOrder = new ClassDefClassDefSortOrder((ClassDefClassDefSortOrder) iter3.next());
                        if(newSortOrder != null)
                        {
                            newSortOrder.setClassDef(newClassDef);
                        }
                    }
                }
            }
        }
        for(Iterator iter = classDefsToRemove.iterator(); iter.hasNext();) {
            ClassDef classDef = (ClassDef) iter.next();
            this.classDefs.remove(classDef);
        }
    }

    public ClassDef(String uid) {
        this.id = uid;
    }

    public ClassDef(String uid, String name) {
        this(uid);
        this.name = name;
    }

    public ClassDef(String uid, String name, List<ClassDef> classDefs, ArrayList<AttributeDef> attributeDefs) {
        this(uid, name);
        this.classDefs = classDefs;
        this.attributeDefs = attributeDefs;
    }

    @Id
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @Column
    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToMany
    @OrderBy("name")
    public List<AttributeDef> getAttributeDefs() {
        return this.attributeDefs;
    }

    public List<AttributeDef> doGetAttributeDefsSorted() {
        return sortAttributeDefs(this.attributeDefs);
    }

    public List<AttributeDef> sortAttributeDefs(List<AttributeDef> attributeDefs) {
        List<AttributeDef> attributeDefsSorted = new ArrayList<AttributeDef>();
        List<ClassDefAttributeDefSortOrder> attributeDefSortOrders = new ArrayList<ClassDefAttributeDefSortOrder>();
        List<AttributeDef> unsorted = new ArrayList<AttributeDef>();
        for(int i = 0; i < attributeDefs.size(); i++)
        {
            AttributeDef attributeDef = attributeDefs.get(i);
            ClassDefAttributeDefSortOrder sortOrder = this.findAttributeDefSortOrder(attributeDef);
            if(sortOrder != null) {
                attributeDefSortOrders.add(sortOrder);
            }
            else
            {
                unsorted.add(attributeDef);
            }
        }
        Collections.sort(attributeDefSortOrders);
        for(int i = 0; i < attributeDefSortOrders.size(); i++)
        {
            ClassDefAttributeDefSortOrder sortOrder = attributeDefSortOrders.get(i);
            AttributeDef attributeDef = null;
            for(int j = 0; j < attributeDefs.size(); j++) {
                AttributeDef tAttributeDef = attributeDefs.get(j);
                if(tAttributeDef.getId().compareTo(sortOrder.getObjId()) == 0)
                {
                    attributeDef = tAttributeDef;
                    break;
                }
            }
            if(attributeDef != null) {
                attributeDefsSorted.add(attributeDef);
            }
        }
        if(unsorted.size() > 0) {
            attributeDefsSorted.addAll(unsorted);
        }
        return attributeDefsSorted;
    }

    public void setAttributeDefs(List<AttributeDef> attributeDefs) {
        this.attributeDefs = attributeDefs;
    }

    public void addAttributeDef(AttributeDef def) {
        this.getAttributeDefs().add(def);
    }

    public List<AttributeDef> findInheritedAttributeDefs() {
        List<ClassDef> traversedClassDefs = new ArrayList<ClassDef>();
        return recursiveFindInheritedAttributeDefs(this, traversedClassDefs, false);
    }

    private List<AttributeDef> recursiveFindInheritedAttributeDefs(ClassDef classDef, List<ClassDef> traversedClassDefs, boolean includeGivenClassDef) {
        List inheritedAttributeDefs = new ArrayList<AttributeDef>();
        if(classDef != null) {
            if(classDef.getParent() != null) {
                if(!traversedClassDefs.contains(classDef)) {
                    traversedClassDefs.add(classDef);
                    List parentAttributeDefs = recursiveFindInheritedAttributeDefs(classDef.getParent(), traversedClassDefs, true);
                    for (int i = 0; i < parentAttributeDefs.size(); i++) {
                        AttributeDef tAttributeDef = (AttributeDef) parentAttributeDefs.get(i);
                        if (!inheritedAttributeDefs.contains(tAttributeDef)) {
                            inheritedAttributeDefs.add(tAttributeDef);
                        }
                    }
                }
            }
            if(includeGivenClassDef) {
                List attributeDefs = classDef.doGetAttributeDefsSorted();
                for (int i = 0; i < attributeDefs.size(); i++) {
                    AttributeDef tAttributeDef = (AttributeDef) attributeDefs.get(i);
                    if (!inheritedAttributeDefs.contains(tAttributeDef)) {
                        inheritedAttributeDefs.add(tAttributeDef);
                    }
                }
            }
        }
        return inheritedAttributeDefs;
    }

    public List<AttributeDef> findAllAttributeDefs()
    {
        List<AttributeDef> allAttributeDefs = new ArrayList<AttributeDef>();
        List inheritedAttributeDefs = findInheritedAttributeDefs();
        for (int i = 0; i < inheritedAttributeDefs.size(); i++) {
            AttributeDef tAttributeDef = (AttributeDef) inheritedAttributeDefs.get(i);
            if (!allAttributeDefs.contains(tAttributeDef)) {
                allAttributeDefs.add(tAttributeDef);
            }
        }
        List attributeDefs = doGetAttributeDefsSorted();
        for (int i = 0; i < attributeDefs.size(); i++) {
            AttributeDef tAttributeDef = (AttributeDef) attributeDefs.get(i);
            if (!allAttributeDefs.contains(tAttributeDef)) {
                allAttributeDefs.add(tAttributeDef);
            }
        }
        return allAttributeDefs;
    }

    @ManyToOne(fetch=FetchType.LAZY)
    @JoinColumn(name="parent", nullable = true)
    public ClassDef getParent() {
        return parent;
    }

    public void setParent(ClassDef parent) {
        this.parent = parent;
    }

    @OneToMany(fetch= FetchType.LAZY, cascade = {CascadeType.ALL}, mappedBy="parent")
    @OrderBy("name")
    public List<ClassDef> getClassDefs() {
        return this.classDefs;
    }

    public List<ClassDef> doGetClassDefsSorted() {
        return sortClassDefs(this.classDefs);
    }

    public List<ClassDef> sortClassDefs(List<ClassDef> classDefs) {
        List<ClassDef> classDefsSorted = new ArrayList<ClassDef>();
        List<ClassDefClassDefSortOrder> classDefSortOrders = new ArrayList<ClassDefClassDefSortOrder>();
        List<ClassDef> unsorted = new ArrayList<ClassDef>();
        for(int i = 0; i < classDefs.size(); i++)
        {
            ClassDef classDef = classDefs.get(i);
            ClassDefClassDefSortOrder sortOrder = this.findClassDefSortOrder(classDef);
            if(sortOrder != null) {
                classDefSortOrders.add(sortOrder);
            }
            else
            {
                unsorted.add(classDef);
            }
        }
        Collections.sort(classDefSortOrders);
        for(int i = 0; i < classDefSortOrders.size(); i++)
        {
            ClassDefClassDefSortOrder sortOrder = classDefSortOrders.get(i);
            ClassDef classDef = null;
            for(int j = 0; j < classDefs.size(); j++) {
                ClassDef tClassDef = classDefs.get(j);
                if(tClassDef.getId().compareTo(sortOrder.getObjId()) == 0)
                {
                    classDef = tClassDef;
                    break;
                }
            }
            if(classDef != null) {
                classDefsSorted.add(classDef);
            }
        }
        if(unsorted.size() > 0) {
            classDefsSorted.addAll(unsorted);
        }
        return classDefsSorted;
    }

    public void setClassDefs(List<ClassDef> classDefs) {
        this.classDefs = classDefs;
    }

    public void addClassDef(ClassDef def) {
        // NOTE: The schema will be set when this object is added to the schema in copy/create.
        def.setParent(this);
        this.getClassDefs().add(def);
    }

    @OneToMany(fetch = FetchType.LAZY, cascade = {CascadeType.ALL}, mappedBy = "classDef")
    public List<ClassDefAttributeDefSortOrder> getAttributeDefSortOrders() {
        return attributeDefSortOrders;
    }

    public void clearAttributeDefSortOrders() {
        this.attributeDefSortOrders.clear();
    }

    public void setAttributeDefSortOrders(List<ClassDefAttributeDefSortOrder> attributeDefSortOrders) {
        this.attributeDefSortOrders = attributeDefSortOrders;
    }

    public void addAttributeDefSortOrder(ClassDefAttributeDefSortOrder def) {
        def.setClassDef(this);
        this.getAttributeDefSortOrders().add(def);
    }

    public ClassDefAttributeDefSortOrder findAttributeDefSortOrder(AttributeDef attributeDef)
    {
        ClassDefAttributeDefSortOrder sortOrder = null;
        for(ClassDefAttributeDefSortOrder tSortOrder : this.attributeDefSortOrders)
        {
            int results = tSortOrder.getObjId().compareTo(attributeDef.getId());
            if(results == 0)
            {
                sortOrder = tSortOrder;
                break;
            }
        }
        return sortOrder;
    }

    @OneToMany(fetch = FetchType.LAZY, cascade = {CascadeType.ALL}, mappedBy = "classDef")
    public List<ClassDefClassDefSortOrder> getClassDefSortOrders() {
        return classDefSortOrders;
    }

    public void clearClassDefSortOrders() {
        this.classDefSortOrders.clear();
    }

    public void setClassDefSortOrders(List<ClassDefClassDefSortOrder> ClassDefSortOrders) {
        this.classDefSortOrders = ClassDefSortOrders;
    }

    public void addClassDefSortOrder(ClassDefClassDefSortOrder def) {
        def.setClassDef(this);
        this.getClassDefSortOrders().add(def);
    }

    public ClassDefClassDefSortOrder findClassDefSortOrder(ClassDef ClassDef)
    {
        ClassDefClassDefSortOrder sortOrder = null;
        for(ClassDefClassDefSortOrder tSortOrder : this.classDefSortOrders)
        {
            int results = tSortOrder.getObjId().compareTo(ClassDef.getId());
            if(results == 0)
            {
                sortOrder = tSortOrder;
                break;
            }
        }
        return sortOrder;
    }

    @Column
    public String getColor() {
		return color;
	}

	public void setColor(String color) {
		this.color = color;
	}

    @ManyToOne
    public AnnotationSchema getAnnotationSchema() {
        return annotationSchema;
    }

    public void setAnnotationSchema(AnnotationSchema annotationSchema) {
        this.annotationSchema = annotationSchema;
    }

    @Version
    public Timestamp getVersion() {
        return version;
    }

    public void setVersion(Timestamp version) {
        this.version = version;
    }

    public String toString() {
        return ToStringBuilder.reflectionToString(this);
    }

    public int compareTo(ClassDef compObj) {

        return compare(this, compObj);
    }

    @Transient
    public String getTypeSystemClassName(){
        if (GenericValidator.isBlankOrNull(name)) {
            return null;
        } else {
            return name.replaceAll("\\s", "").replaceAll("[^a-zA-Z0-9]+", "");
        }
    }

    static int compare(ClassDef obj1, ClassDef obj2) {

        String objName1 = obj1.getName();
        String objName2 = obj2.getName();
        return objName1.compareTo(objName2);
    }

    public void sortAttributeDefsByIdToOrderMap(Map<String, String> idToOrderMap) {
        Collections.sort(this.attributeDefs, new AttributeDefComparator(idToOrderMap));
    }

    private static class AttributeDefComparator implements Comparator<AttributeDef> {
        private Map<String, String> idToOrderMap;

        private AttributeDefComparator(Map<String, String> idToOrderMap) {
            this.idToOrderMap = idToOrderMap;
        }

        public int compare(AttributeDef o1, AttributeDef o2) {
            String id1 = o1.getId();
            String id2 = o2.getId();
            String value1 = (String)idToOrderMap.get(id1);
            String value2 = (String)idToOrderMap.get(id2);
            if(value1 == null)
            {
                return -1;
            }
            if(value2 == null)
            {
                return 1;
            }
            Integer order1 = new Integer(value1);
            Integer order2 = new Integer(value2);
            return order1.compareTo(order2);
        }
    }

    public void sortClassDefClassDefsByIdToOrderMap(Map<String, String> idToOrderMap) {
        Collections.sort(this.classDefs, new ClassDefComparator(idToOrderMap));
    }

    private static class ClassDefComparator implements Comparator<ClassDef> {
        private Map<String, String> idToOrderMap;

        private ClassDefComparator(Map<String, String> idToOrderMap) {
            this.idToOrderMap = idToOrderMap;
        }

        public int compare(ClassDef o1, ClassDef o2) {
            String id1 = o1.getId();
            String id2 = o2.getId();
            String value1 = (String)idToOrderMap.get(id1);
            String value2 = (String)idToOrderMap.get(id2);
            if(value1 == null)
            {
                return -1;
            }
            if(value2 == null)
            {
                return 1;
            }
            Integer order1 = new Integer(value1);
            Integer order2 = new Integer(value2);
            return order1.compareTo(order2);
        }
    }

    public void clearSorts()
    {
        this.attributeDefSortOrders.clear();
        this.classDefSortOrders.clear();
    }
}
