/*

Siesta 3.0.1
Copyright(c) 2009-2015 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
/**
 @class Siesta.Recorder.Recorder

Low level class which records the events of the window it's attached to. It records basic mouse and key events,
but does not record scroll events and other browser type events. Since it's JS based, we cannot record
native dialog interactions, such as alert, print or confirm etc.

It tries to coalesce certain event patterns into higher order events (click, drag etc).

*/
Class('Siesta.Recorder.Recorder', {
    does : [
        JooseX.Observable
    ],

    has : {
        active              : null,
        
        extractor           : null,

        extractorClass      : Siesta.Recorder.TargetExtractor.ExtJS,

        extractorConfig     : null,
        
        /**
         * @cfg {Array[String]/String} uniqueComponentProperty A string or an array of strings, containing attribute names that the Recorder will use to identify Ext JS components.
         */
        uniqueComponentProperty : null,

        /**
         * @cfg {String} uniqueDomNodeProperty A property that will be used to uniquely identify DOM nodes.
         */
        uniqueDomNodeProperty : 'id',

        /**
         * @cfg {Boolean} recordOffsets true to record the offset to each targeted DOM element for recorded actions to make sure the recorded action can be played back with exact precision.
         * Should be avoided for most cases, to let Siesta pick the center of each target.
         */
        recordOffsets       : true,

        // ignore events generated by Siesta (bypass in normal use, but for testing recorder we need it)
        ignoreSynthetic     : true,

        // The window this recorder is observing for events
        window              : null,

        // Fire a mouseidle event if mouse doesn't move for a while.
        idleTimeout         : 3000,

        eventsToRecord      : {
            init : function () {
                return [
                    "keydown",
                    "keypress",
                    "keyup",

                    "click",
                    "dblclick",
                    "contextmenu",
                    "mousedown",
                    "mouseup"
                ];
            }
        },

        // "raw" log of all dom events
        events              : Joose.I.Array,
        
        actions             : Joose.I.Array,
        actionsByEventId    : Joose.I.Object
    },

    
    methods : {

        initialize : function () {
            this.onUnload                   = Ext.Function.bind(this.onUnload, this);
            this.onFrameLoad                = Ext.Function.bind(this.onFrameLoad, this);
            this.onDomEvent                 = Ext.Function.bind(this.onDomEvent, this);
            this.resetMouseMoveListener     = Ext.Function.bind(this.resetMouseMoveListener, this);

            var extractorConfig             = $.extend({
                saveOffset              : this.recordOffsets,
                uniqueComponentProperty : this.uniqueComponentProperty,
                uniqueDomNodeProperty   : this.uniqueDomNodeProperty
            }, this.extractorConfig || {});

            this.extractor                  = new this.extractorClass(extractorConfig);
            this.onBodyMouseMove            = this.throttleMouseMoveListener(this.onBodyMouseMove, this.idleTimeout, this);
        },

        
        isSamePoint : function (event1, event2) {
            return event1.x == event2.x && event1.y == event2.y;
        },

        
        clear          : function () {
            this.events     = []
            this.actions    = []
            
            this.fireEvent('clear', this)
        },

        
        // We monitor page loads so the recorder can add a waitForPageLoad action
        onUnload : function () {
            var actions = this.actions,
                last = actions.length && actions[actions.length - 1];

            if (last && last.target) {
                last.waitForPageLoad = true;
            }
        },

        // After frame has loaded, stop listening to old window and restart on new frame window
        onFrameLoad    : function (event) {
            this.stop();
            
            this.attach(event.target.contentWindow);
            
            this.start();
        },

        /*
         * Attaches the recorder to a Window object
         * @param {Window} windo The window to attach to.
         **/
        attach         : function (window) {
            this.stop()
            
            // clear only events, keep the actions
            this.events = []
            
            this.window = window;
        },

        /*
         * Starts recording events of the current Window object
         **/
        start          : function () {
            this.stop();
            
            this.active         = Date.now();
            this.onStart();
            this.fireEvent('start', this);
        },

        /*
         * Stops the recording of events
         **/
        stop           : function () {
            if (this.active) {
                this.active     = null;
                this.onStop();
                this.fireEvent('stop', this);
            }
        },

        
        getRecordedEvents : function () {
            return this.events;
        },
        
        
        getRecordedActions : function () {
            return this.actions
        },

        
        getRecordedActionsAsSteps : function () {
            return Joose.A.map(this.actions, function (action) {
                return action.asStep()
            })
        },
        
        
        onDomEvent : function (e) {
            var target          = e.target
            
            // Never trust IE - target may be absent
            // Ignore events from played back test (if user plays test and records before it's stopped)
            if (!target || (this.ignoreSynthetic && e.synthetic)) return;
            
            var eventType       = e.type
            var isKeyEvent      = eventType.match(/^key/)
            
            var keys            = Siesta.Test.Simulate.KeyCodes().keys

            // Ignore special keys which are used only in combination with other keys
            if (isKeyEvent && (e.keyCode === keys.SHIFT || e.keyCode === keys.CTRL || e.keyCode === keys.ALT)) return;

            var event           = Siesta.Recorder.Event.fromDomEvent(e)

            // this "reset" will ensure that "onBodyMouseMove" handler will be called after "idleTimeout"
            // after any other dom event
            this.resetMouseMoveListener();

            this.convertToAction(event)
            
            this.events.push(event)
            
            this.fireEvent('domevent', event)
        },
        
        
        eventToAction : function (event, actionName) {
            var type        = event.type
            
            if (!actionName)
                if (type.match(/^key/))
                    // convert all key events to type for now
                    actionName  = 'type'
                else
                    actionName  = type
            
            var config      = {
                action          : actionName,
                
                target          : this.extractor.getTargets(event),
                
                options         : event.options,
                
                sourceEvent     : event
            }

            // `window` object to which the event target belongs
            var win             = event.target.ownerDocument.defaultView;

            // Case of nested iframe
            if (win !== this.window) {

                if (!win.frameElement.id) {
                    throw 'To record events in a nested iframe, please set an "id" property on your frames';
                }

                // Prepend the frame id to each suggested target
                config.target = config.target.filter(function(actionTarget) {
                    if (typeof(actionTarget.target) === 'string') {
                        actionTarget.target = '#' + win.frameElement.id + ' -> ' + actionTarget.target;

                        return true;
                    }
                    // Skip array coordinates for nested iframes, make little sense
                    return false;
                });
            }

            return new Siesta.Recorder.Action(config)
        },
        
        
        recordAsAction : function (event, actionName) {
            var action      = this.eventToAction(event, actionName)
            
            if (action) this.addAction(action)
        },
        
        
        addAction : function (action) {
            this.actions.push(action)
            if (action.sourceEvent) this.actionsByEventId[ action.sourceEvent.id ] = action
            
            this.fireEvent('actionadd', action)
        },
        
        
        removeAction : function (actionToRemove) {
            var actions     = this.actions;
            
            for (var i = 0; i < actions.length; i++) {
                var action  = actions[ i ]
                
                if (action == actionToRemove) {
                    actions.splice(i, 1)
                    
                    if (action.sourceEvent) delete this.actionsByEventId[ action.sourceEvent.id ]
                    
                    this.fireEvent('actionremove', actionToRemove)
                    break;
                }
            }
        },
        
        
        removeActionByEventId : function (eventId) {
            this.removeAction(this.getActionByEventId(eventId))
        },
        

        removeActionByEvent : function (event) {
            this.removeAction(this.getActionByEventId(event.id))
        },
        
        
        getActionByEventId : function (eventId) {
            return this.actionsByEventId[ eventId ]
        },
        
        
        getLastAction : function () {
            return this.actions[ this.actions.length - 1 ]
        },
        

        // Method which tries to identify "composite" DOM interactions such as 'click/contextmenu' (3 events), double click
        // but also complex scenarios such as 'drag'
        convertToAction : function (event) {
            var events      = this.events,
                length      = events.length,
                tail        = events[events.length - 1];

            var type        = event.type

            if (type == 'keypress' || type == 'keyup' || type == 'keydown') {
                var KC              = Siesta.Test.Simulate.KeyCodes();
                var isSpecial       = type == 'keydown' && (KC.isSpecial(event.keyCode) || KC.isNav(event.keyCode));
                var prevSpecial     = type == 'keypress' && tail && tail.type == 'keydown' && (KC.isSpecial(tail.keyCode) || KC.isNav(tail.keyCode));

                if (type == 'keypress' && !isSpecial && !prevSpecial || (type == 'keydown' && isSpecial)) {
                    var lastAction      = this.getLastAction()

                    var text            = isSpecial ? '[' + KC.fromCharCode(event.charCode, true) + ']' : String.fromCharCode(event.charCode);

                    if (lastAction && lastAction.action === 'type') {
                        lastAction.value    += text

                        this.fireEvent('actionupdate', lastAction)
                    } else {
                        this.addAction(new Siesta.Recorder.Action({
                            action          : 'type',

                            value           : text,

                            sourceEvent     : event,
                            options         : event.options
                        }))
                    }

                    return
                }

                // ignore 'keydown' events
                return
            }

            // if there's no already recorded events - there's nothing to coalsce
            if (!length) {
                this.recordAsAction(event)
                
                return
            }
                
            var tail        = events[ length - 1 ],
                tailPrev    = length >= 2 ? events[ length - 2 ] : null;
            
            var tailType    = tail.type

            // when user clicks on the <label> with "for" attribute 2 "click" events are triggered
            // just ignore the 2nd event and not record it as action
            // in FF, the 2nd "click" will have 0, 0 coordinates, so we have to disable `isSamePoint` extra sanity check
            if (type == 'click' && tailType == 'click' /*&& this.isSamePoint(event, tail)*/ && tail.target.getAttribute('for')) {
                return
            }

            if (type == 'dblclick') {
                // removing the last `click` action - one click event will still remain
                this.removeAction(this.getLastAction())
                
                this.getLastAction().action = 'dblclick'
                
                this.fireEvent('actionupdate', this.getLastAction())

                return
            }


            // if mousedown/up happened in a row in different points - this is considered to be a drag operation
            if (tailType == 'mousedown' && type == 'mouseup' && event.button == tail.button && !this.isSamePoint(event, tail)) {
                var lastAction      = this.getLastAction()
                
                // if we've recorded "moveCursorTo" in between mousedown / up (we don't record mousemove, so tail event will be still
                // mousedown) then we don't need to convert "mouseup" into drag
                if (lastAction.action != 'moveCursorTo') {
                    lastAction.action   = 'drag'
                    
                    lastAction.by       = [ event.x - tail.x, event.y - tail.y ]
                    
    //                var toTarget        = new Siesta.Recorder.Target({ targets : this.extractor.getTargets(event) })
    //                
    //                if (!toTarget.isTooGeneric()) lastAction.toTarget = toTarget
                    
                    this.fireEvent('actionupdate', lastAction)
                
                    return
                } else {
                    this.addAction(new Siesta.Recorder.Action({
                        action          : 'moveCursorTo',
                        
                        target          : this.extractor.getTargets(event),
                        
                        sourceEvent     : event,
                        options         : event.options
                    }))
                    
                    // the `mouseup` action will be recorded as the last `this.recordAsAction(event)` statement
                }
            }

            // In some situations the mouseup event may remove/overwrite the current element and no click will be triggered
            // so we need to catch drag operation on mouseup (see above) and ignore following "click" event
            if (type === 'click' && this.getLastAction() && this.getLastAction().action === 'drag') {
                return
            }

            if (tailPrev && (type === 'click' || type === 'contextmenu')) {
                if (
                    // Verify tail
                    tailType == 'mouseup' &&
                    event.button == tail.button &&
                    event.button == tailPrev.button &&
                    this.isSamePoint(event, tail) &&

                    // Verify previous tail
                    tailPrev.type == 'mousedown' &&
                    (event.target == tail.target || $.contains(event.target, tail.target) || $.contains(tail.target, event.target)) &&
                    (event.target == tailPrev.target || $.contains(event.target, tailPrev.target) || $.contains(tailPrev.target, event.target)) &&
                    this.isSamePoint(event, tailPrev)
                ) {
                    this.removeActionByEvent(tail)
                    this.removeActionByEvent(tailPrev)
                    
                    this.recordAsAction(event)
                    
                    return
                }
            }
            
            this.recordAsAction(event)
        },

        
        onStart : function () {
            var me              = this,
                testWindow      = me.window,
                doc             = testWindow.document,
                body            = doc.body,
                frameWindows    = this.getNestedFrames().map(function(frame) { return frame.contentWindow; });

            // Listen to test window and any frames nested in it
            [ testWindow ].concat(frameWindows).forEach(function (win) {
                me.registerWindowListeners(win);

                win.frameElement && win.frameElement.addEventListener('load', function() {
                    me.registerWindowListeners(win);
                });
            })

            body.addEventListener('mousemove', this.onBodyMouseMove);
            $(body).bind('mouseleave', this.resetMouseMoveListener);

            testWindow.frameElement && testWindow.frameElement.addEventListener('load', this.onFrameLoad);
            testWindow.addEventListener('unload', this.onUnload);
        },

        
        registerWindowListeners : function (win) {
            var me = this;

            // We might not have access to the frame window if it's in another domain
            try {
                var foo = win.document;
            } catch(e) { return; }

            me.eventsToRecord.forEach(function (name) {
                win.document.addEventListener(name, me.onDomEvent, true);
            });
        },
        

        deregisterWindowListeners : function (win) {
            var me = this;

            try {
                var foo = win.document;
            } catch(e) { return; }

            me.eventsToRecord.forEach(function (name) {
                win.document.removeEventListener(name, me.onDomEvent, true);
            });
        },

        // Returns only frames on the same domain
        getNestedFrames : function() {
            var testWindow      = this.window,
                doc             = testWindow.document;

            return Array.prototype.slice.apply(doc.getElementsByTagName('iframe')).filter(function(frame) {
                try {
                    var foo = frame.contentWindow.document;
                } catch(e) { return false; }

                return true;
            });
        },
        
        onStop : function () {
            var me              = this,
                testWindow      = me.window,
                doc             = testWindow.document,
                body            = doc.body,
                frameWindows    = this.getNestedFrames().map(function(frame) { return frame.contentWindow; });

            // Unlisten to test window and any frames nested in it
            [ testWindow ].concat(frameWindows).forEach(function (win) {
                me.deregisterWindowListeners(win);

                win.frameElement && win.frameElement.addEventListener('unload', function() {
                    me.deregisterWindowListeners(win);
                });
            })
            
            body.removeEventListener('mousemove', this.onBodyMouseMove);
            $(body).unbind('mouseleave', this.resetMouseMoveListener);

            testWindow.frameElement && testWindow.frameElement.removeEventListener('load', this.onFrameLoad);
            testWindow.removeEventListener('unload', this.onUnload);

            this.resetMouseMoveListener()
        },
        

        resetMouseMoveListener : function () {
            clearTimeout(this.mouseMoveDeferTimer);
        },

        // This allows a user to indicate that the cursor should be move to a certain place
        // if mouse is still for a period (idleTimeout) of time.
        onBodyMouseMove        : function (e, t) {
            // Skip mouse moves in frames
            if (e.target.ownerDocument !== this.window.document) return;

            var mouseMoveEvent  = new Siesta.Recorder.Event.fromDomEvent(e)
            
            this.addAction(new Siesta.Recorder.Action({
                action          : 'moveCursorTo',
                
                target          : this.extractor.getTargets(mouseMoveEvent),
                
                sourceEvent     : mouseMoveEvent,
                
                options         : mouseMoveEvent.options
            }))
        },
        

        throttleMouseMoveListener : function (fn, threshhold, scope) {
            var last,
                me              = this;

            return function () {
                var context     = scope || this;
                var now         = Date.now(),
                    args        = arguments;

                if (last && now < last + threshhold) {
                    clearTimeout(me.mouseMoveDeferTimer);

                    me.mouseMoveDeferTimer = setTimeout(function () {
                        last    = now;
                        fn.apply(context, args);
                    }, threshhold);
                } else {
                    last        = now;
                }
            };
        }
    }
    // eof methods
});
