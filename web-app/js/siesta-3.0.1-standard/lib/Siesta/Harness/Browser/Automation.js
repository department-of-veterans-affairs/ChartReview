/*

Siesta 3.0.1
Copyright(c) 2009-2015 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/products/siesta/license

*/
Role('Siesta.Harness.Browser.Automation', {
    
    does        : [
        Siesta.Role.ConsoleReporter,
        Siesta.Util.Role.CanFormatStrings
    ],
    
    has : {
        // a regex for the test the url (can be provided by automation launchers) only matched tests will be run
        includeTests        : null,
        // a regex for the test the url (can be provided by automation launchers), matched tests will not be run
        excludeTests        : null,
        
        testPage            : null,
        testPageSize        : 5,
        
        pageCount           : null,
        
        outputLog           : '__NULL__',
        
        lastActivity        : null,
        exitCode            : null,
        
        launchedDesc        : null,
        
        currentScriptExecution          : null,
        
        // this flag indicates that code coverage report is being generated by the automation launcher
        // it is possible for user to specify the "enableCodeCoverage" option to true in harness
        // but then later run the launcher on it, w/o coverage report generation
        enableCodeCoverageAutomation    : false
    },
    
    
    override : {
        
        setup : function () {
            if (this.isAutomated) {
                this.speedRun           = true
                this.forcedRunCore      = 'sequential'
                this.transparentEx      = false
                this.keepNLastResults   = 0
                this.needUI             = false
                this.needSummaryMessage = false
                
                this.enableCodeCoverageAutomation = this.getQueryParam('enableCodeCoverage') == 'true'
                this.enableCodeCoverage = this.enableCodeCoverageAutomation || this.enableCodeCoverage
                
                var coverageUnit        = this.getQueryParam('coverageUnit')
                
                if (coverageUnit) this.coverageUnit = coverageUnit
                
                this.hasPreviousReport  = this.getQueryParam('hasPreviousReport') == 'true'
                this.coverageNoSource   = this.getQueryParam('coverageNoSource') == 'true'
                
                this.waitForTimeout     = this.waitForTimeout * 3
                this.defaultTimeout     = this.defaultTimeout * 3
                
                var includeTests        = this.getQueryParam('include')
                var excludeTests        = this.getQueryParam('exclude')
                
                if (includeTests) this.includeTests = decodeURIComponent(includeTests)
                if (excludeTests) this.excludeTests = decodeURIComponent(excludeTests)
                
                this.testPageSize       = this.getQueryParam('pageSize') || this.testPageSize
                
                var page                = this.getQueryParam('page')
                if (page) this.testPage = Number(page)
    
                
                if (this.getQueryParam('verbose')) this.verbosity++
                
                var pause               = this.getQueryParam('pause')
                
                this.pauseBetweenTests  = pause != null ? pause : 3000
                
                this.lastActivity       = new Date()
                
                var me                  = this
                
                window.onerror          = function (message, url, lineNumber, col, error) {
                    me.warn("[ERROR] message : " + message)
                    me.warn("[ERROR] url     : " + url)
                    me.warn("[ERROR] line    : " + lineNumber)

                    if (col) me.warn("[ERROR] col     : " + col)
                    if (error && error.stack) me.warn("[ERROR] stack   : " + error.stack)
                }
            }
            
            this.SUPERARG(arguments)
        },
        
        
        launch : function (descriptors, callback, errback) {
            var includeTests    = this.includeTests ? new RegExp(this.includeTests) : null
            var excludeTests    = this.excludeTests ? new RegExp(this.excludeTests) : null
            
            var filtered        = []
            
            if (includeTests || excludeTests) {
                Joose.A.each(this.flattenDescriptors(descriptors), function (desc) {
                    if (includeTests && !includeTests.test(desc.url)) return
                    if (excludeTests && excludeTests.test(desc.url)) return
                    
                    filtered.push(desc)
                })
            } else
                filtered        = this.flattenDescriptors(descriptors)
                
            var testPageSize    = this.testPageSize
            var testPage        = this.testPage
                
            if (testPage != null) {
                this.pageCount  = Math.ceil(filtered.length / testPageSize)
                filtered        = filtered.slice(testPage * testPageSize, (testPage + 1) * testPageSize)
            }
            
            if (this.isAutomated && !filtered.length) {
                this.warn("Filter regexp doesn't match any test URL - exiting")
                this.exit(4)
                
                return
            }
            
            this.SUPER(this.launchedDesc = filtered, callback, errback)
        }
    },
    
    
    after : {
        
        onTestUpdate : function () {
            if (this.isAutomated) this.lastActivity = new Date()
        }
    },
    
    
    methods : {
        
        restartFromNextTest : function () {
            this.lastActivity   = new Date()
            
            var launchOptions   = this.launches[ this.currentLaunchId ]
            var hasTestsToDo    = launchOptions.descriptorsLeft && launchOptions.descriptorsLeft.length > 0
            
            launchOptions.descriptorsLeft && this.runCoreSequential(launchOptions.descriptorsLeft, launchOptions.contentManager, launchOptions, launchOptions.callback)
            
            return hasTestsToDo
        },
        
        
        getPageState : function () {
            return {
                lastActivity        : this.lastActivity - 0,
                log                 : this.flushLog(),
                exitCode            : this.exitCode,
                commands            : this.flushAutomationCommands()
            }
        },
        
        
        allPagesPassed : function (pageReports) {
            var allPassed       = true
            
            Joose.A.each(pageReports, function (pageReport) {
                if (!pageReport || !pageReport.passed) {
                    allPassed = false
                    return false
                }
            })
            
            return allPassed
        },
        
        
        flushLog : function () {
            var result  = this.outputLog.replace(/\n$/, '');
            
            this.outputLog = '__NULL__'
            
            return result
        },
        
        
        getLastActivity : function () {
            return this.lastActivity - 0
        },
        
        
        log : function () {
            if (this.isAutomated) {
                var str     = Array.prototype.slice.call(arguments).join(' ') + '\n'
                
                if (this.outputLog == '__NULL__')
                    this.outputLog = str
                else
                    this.outputLog += str 
            }
        },
        
        
        exit : function (code) {
            if (this.isAutomated) this.exitCode = code || 0
        },
        
        
        generateUnifiedPageReport : function (params) {
            params          = params || {}
            var me          = this
            
            var report      = {
                testSuiteName       : this.title || '',
                
                startDate           : this.startDate,
                endDate             : this.endDate || (new Date() - 0),
                
                passed              : this.allPassed(),
                
                testCases           : []
            }
            
            Joose.A.each(this.flattenDescriptors(params.descriptors || this.launchedDesc || this.descriptors), function (descriptor) {
                var test    = me.getTestByURL(descriptor.url)
                
                // ignore missing tests (could be skipped by test filtering)
                if (!test) return
                
                report.testCases.push(descriptor.isMissing ? { fileIsMissing : true } : test.getResults().toJSON())
            })
            
            return params.asJSON ? report : JSON.stringify(report)
        },
        
        
        combinePageReports : function (pageReports) {
            if (!pageReports || !pageReports.length) throw new Error("No pages to combine")
            
            var combinedReport
            
            Joose.A.each(pageReports, function (pageReport, index) {
                // first page
                if (!index) {
                    combinedReport              = Joose.O.copy(pageReport)
                    
                    combinedReport.testCases    = combinedReport.testCases.slice()
                } else
                    Joose.A.each(pageReport.testCases, function (el) {
                        combinedReport.testCases.push(el)
                    })
                    
                if (index == pageReports.length - 1)
                    combinedReport.endDate      = pageReport.endDate
            })
            
            combinedReport.passed   = this.allPagesPassed(pageReports)
            
            return combinedReport
        },
        
        
        getAutomatedSummaryMessage : function (pageReports) {
            if (!arguments.length) pageReports = __PAGE_REPORTS__
            
            var combinedReport      = this.combinePageReports(pageReports)
        
            var testCases           = combinedReport.testCases
            
            var testsTotal          = testCases.length
            var testsFailed         = 0
            
            var assertionsTotal     = 0
            var assertionsFailed    = 0
            
            var todoPassed          = 0
            var todoFailed          = 0
            
            var timeTotal           = testCases[ testCases.length - 1 ].endDate - testCases[ 0 ].startDate
            var durationStr         = timeTotal + 'ms'
            
            if (timeTotal >= 1000) {
                timeTotal           = timeTotal / 1000
                durationStr         = timeTotal + 's'
                
                if (timeTotal >= 60) {
                    durationStr     = Math.floor(timeTotal / 60) + 'm ' + Math.floor(timeTotal % 60) + 's'
                    timeTotal       = timeTotal / 60
                    
                    if (timeTotal >= 60) {
                        durationStr = Math.floor(timeTotal / 60) + 'h ' + Math.floor(timeTotal % 60) + 'm'
                    }
                }
            }
            
            var cascadeAssertions   = function (testInfo, func) {
//                var queue           = testInfo.assertions.slice()
//                
//                while (queue.length) {
//                    var assertion   = queue.shift()
//                    
//                    if (assertion.type == 'Siesta.Result.Assertion') func(assertion)
//                    if (assertion.type == 'Siesta.Result.SubTest') queue.push.apply(queue, assertion.assertions)
//                }
                
                for (var i = 0; i < testInfo.assertions.length; i++) {
                    var assertion   = testInfo.assertions[ i ]
                    
                    if (assertion.type == 'Siesta.Result.Assertion') func(assertion)
                    if (assertion.type == 'Siesta.Result.SubTest') cascadeAssertions(assertion, func)
                }
            }
            
            for (var i = 0; i < testCases.length; i++) {
                var testInfo    = testCases[ i ]
                
                if (testInfo.fileIsMissing) {
                    testsFailed++
                } else {
                    if (!testInfo.passed) testsFailed++
                    
                    cascadeAssertions(testInfo, function (assertion) {
                        if (assertion.isTodo) {
                            assertion.passed ? todoPassed++ : todoFailed++
                        } else {
                            assertionsTotal++
                            
                            if (!assertion.passed) assertionsFailed++
                        }
                    })
                }
            }
            
            return this.formatString([            
                '{assertionsPassed} passed, {assertionsFailed} failed assertions took {!timeTotal} to complete'
            ].join('\n'), {
                testsFailed             : testsFailed,
                testsPassed             : testsTotal - testsFailed,
                testsTotal              : testsTotal,
                
                timeTotal               : durationStr,
                
                assertionsTotal         : assertionsTotal,
                assertionsPassed        : assertionsTotal - assertionsFailed,
                assertionsFailed        : assertionsFailed,
                
                todoPassed              : todoPassed,
                todoFailed              : todoFailed
            })
        },
        
        
        // trying to prevent any possibility of the mess with the script
        executeScript : function (scriptId, maxMessageSize, chunk, index, isLast) {
            var currentScriptExecution      = this.currentScriptExecution
            
            if (currentScriptExecution) {
                if (currentScriptExecution.id != scriptId) throw new Error("Another execution in progress")
                if (currentScriptExecution.maxMessageSize != maxMessageSize) throw new Error("`maxMessageSize` has changed")
            } else {
                if (index) throw new Error("Starting from non-zero chunk")
                
                this.currentScriptExecution = currentScriptExecution = new Siesta.Harness.Browser.Automation.ScriptExecution({
                    id              : scriptId,
                    maxMessageSize  : maxMessageSize
                })
            }
            
            currentScriptExecution.addChunk(chunk, index)
            
            if (isLast) {
                currentScriptExecution.execute()
                return this.retrieveScriptResult(scriptId, 0)
            } else {
                return "Chunk received successfully"
            }
        },
        
        
        retrieveScriptResult : function (scriptId, index) {
            var currentScriptExecution      = this.currentScriptExecution
            
            if (!currentScriptExecution) throw new Error("No current script execution")
                
            var res         = currentScriptExecution.getPartialResult(scriptId, index)
            
            if (currentScriptExecution.isDestroyed) this.currentScriptExecution = null
            
            return res
        }
    }
})
//eof Siesta.Harness.Browser.Automation


Siesta.Harness.Browser.my.meta.extend({
    does : [ 
        Siesta.Harness.Browser.Automation,
        Siesta.Harness.Browser.Automation.PhantomJS, 
        Siesta.Harness.Browser.Automation.Selenium,
        Siesta.Harness.Browser.Automation.TeamCityReporter
    ] 
})


Siesta.Harness.meta.extend({
    does : [ 
        Siesta.Harness.Report.JSON,
        Siesta.Harness.Report.JUnit
    ] 
})